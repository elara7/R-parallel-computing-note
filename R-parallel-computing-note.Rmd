---
title: "R-parallel-computing-note"
author: "Zexian Wang"
date: "2017-5-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Motivation

- R core is a single-threaded program.

- Some times our tasks can be done at the same time using different cores/threads of cpus to speed up the codes.

# 2. How

There are two types of parallel computing.

## 2.1. Explicit parallelism

- `parallel` for "lapply"

- `foreach` for "for" 

- `SupR`

- `gpuR`

We need to modify/customize our codes in this case.

It is more flexible.

## 2.2. Implicit parallelism

- `OpenBLAS`/'intel MKL'/'NVIDIA cuBLAS'/'H2O'

We can install [Microsoft R Open](https://mran.microsoft.com/open/) to simplily enable intel MKL without any special operation.

We don't need to modify/customize our codes in this case. All the computation will be automatically accelerated. However, only some kinds of computation can be speed up.

# 3. Testing data and function

## 3.1. Data

```{r, include=FALSE}
source("case.R")
```

## 3.2. Function

```{r}
GetEstAUC <- function(data, method, t) {
  # Method: "Cox"
  auc <- risksetROC(Stime=data$T.20,
                    status=data$status.20, marker=data$M, method=method, 
                    predict.time = t, 
                    plot = F)
  auc$AUC
}

GetEstAUC.span <- function(data, method, t, n) {
  # Method: LocalCox", "Schoenfeld"
  auc <- risksetROC(Stime=data$T.20,
                    status=data$status.20, marker=data$M, method=method, 
                    predict.time = t, span = n^(-0.2),
                    plot = F)
  auc$AUC
}
```

## 3.3. Origin result

```{r}
cind.cox <- numeric(100)
est.diftime.cox <- matrix(NA, nrow = 100, ncol = 9)
for(i in 1:100) {
  auc <- risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)
  auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])
  est.diftime.cox[i, ] <- auc.est
  cind.cox[i] <- auc$Cindex
}
mean(cind.cox)
sd(cind.cox)
colMeans(est.diftime.cox)
apply(est.diftime.cox, 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

## 3.4. Origin speed

```{r}
microbenchmark::microbenchmark({
cind.cox <- numeric(100)
est.diftime.cox <- matrix(NA, nrow = 100, ncol = 9)
for(i in 1:100) {
  auc <- risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)
  auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])
  est.diftime.cox[i, ] <- auc.est
  cind.cox[i] <- auc$Cindex
}
mean(cind.cox)
sd(cind.cox)
colMeans(est.diftime.cox)
apply(est.diftime.cox, 2, sd)
},
times = 10)

# Unit: seconds
#      min       lq     mean   median       uq     max neval
# 3.421313 3.429348 3.483226 3.492596 3.527414 3.54353    10
```

# 4. Packages(Explicit parallelism)

## 4.1. Modify the funciton

```{r}
singlecox <- function(i){
  
  tryCatch({
    auc <- risksetROC::risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)},
    warning = function(w){
      print(paste("warning auc",paste(i,auc$Cindex)))
      auc$Cindex <- NA
    },
    error = function(e){
      print(paste("error auc",paste(i,auc$Cindex)))
      auc$Cindex <- NA
    })
  
  tryCatch({
    auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])},
    warning = function(w){
      print(paste("warning auc.est",paste(i,auc.est)))
      auc.est <- rep(NA,9)
    },
    error = function(e){
      print(paste("error auc.est",paste(i,auc.est)))
      auc.est <- rep(NA,9)
    })
  
  return(c(i,auc.est,auc$Cindex))
}
```

## 4.2. Parallel

### 4.2.1. Load package

```{r}
library(parallel)
```

### 4.2.2. Initial settings

```{r}
# Detect the numbers of cores of the cpu 
no_cores <- detectCores() 
# Initial the environment. In Linux, we can add type="FORK" to improve the performance of memory
cl <- makeCluster(no_cores) 
# Tell the machine that: these objects need to be used
#clusterEvalQ(cl,"risksetROC") # for packages
clusterExport(cl,c("risksetROC","risksetAUC","SIM","seq.ltime","seq.time","GetEstAUC","GetEstAUC.span")) # for functions and objects
```

### 4.2.3. Do the parallel compution using clusterApply/parLapply

```{r}
# Do the parallel compution
result <- clusterApply(cl,1:100,singlecox)
# Collect the result
result <- do.call(rbind,result)
# Get the result
mean(result[,11])
sd(result[,11])
colMeans(result[,2:10])
apply(result[,2:10], 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

```{r}
result <- parLapply(cl,1:100,singlecox)
# Collect the result
result <- do.call(rbind,result)
# Get the result
mean(result[,11])
sd(result[,11])
colMeans(result[,2:10])
apply(result[,2:10], 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```


### 4.2.4. Speed Up!

```{r}
microbenchmark::microbenchmark({
singlecox <- function(i){
  auc <- risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)
  auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])
  return(c(i,auc.est,auc$Cindex))
}
result <- clusterApply(cl,1:100,singlecox)
result <- do.call(rbind,result)
mean(result[,11])
sd(result[,11])
colMeans(result[,2:10])
apply(result[,2:10], 2, sd)
},
times = 10)

# Unit: milliseconds
#      min       lq    mean  median       uq      max neval
# 874.1933 879.9534 934.104 885.451 897.6079 1315.894    10
```

```{r}
microbenchmark::microbenchmark({
singlecox <- function(i){
  auc <- risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)
  auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])
  return(c(i,auc.est,auc$Cindex))
}
result <- parLapply(cl,1:100,singlecox)
result <- do.call(rbind,result)
mean(result[,11])
sd(result[,11])
colMeans(result[,2:10])
apply(result[,2:10], 2, sd)
},
times = 10)

# Unit: milliseconds
                                                                                                                                                      
#      min       lq     mean   median       uq      max neval
# 855.6234 860.8803 899.8512 867.8065 874.6116 1149.639    10
```


### 4.2.5. Stop the parallel environment

```{r}
stopCluster(cl)
```

When you finish your parallel tasks, stop the parallel environment may avoid some unexpected problems.

## 4.3. Foreach

### 4.3.1. Load packages

```{r, include=FALSE}
library(foreach)
library(doParallel)
```

### 4.3.2. Initial settings 

```{r}
cl <- makeCluster(no_cores)
# we need register clusters
registerDoParallel(cl)
```

### 4.3.3. Do the parallel compution

```{r}
resultfor <- foreach(i = 1:100, 
                     .combine = rbind, # function that is used to process the tasks results as they generated
                #    .export = "xxx" # using this parameter to export functions or objects in parent's environments(generally no need)
                     .packages = "risksetROC" # using this parameter to tell machine what packages needed to be loaded
                ) %dopar% singlecox(i)
mean(resultfor[,11])
sd(resultfor[,11])
colMeans(resultfor[,2:10])
apply(resultfor[,2:10], 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

### 4.3.4. Speed Up!

```{r}
microbenchmark::microbenchmark({
resultfor <- foreach(i = 1:100, 
                     .combine = rbind,
                #    .export = "xxx" # using this parameter to export functions or objects in parent's environments(generally no need)
                     .packages = "risksetROC" # using this parameter to export packages
                ) %dopar% singlecox(i)
mean(resultfor[,11])
sd(resultfor[,11])
colMeans(resultfor[,2:10])
apply(resultfor[,2:10], 2, sd)
},
times =10)

#Unit: seconds
                                                                                                                                                      
#      min       lq     mean   median       uq      max neval
# 1.608848 1.620743 1.664498 1.634976 1.671731 1.903167    10
```

### 4.3.5. Stop the parallel environment

```{r}
stopImplicitCluster()
```

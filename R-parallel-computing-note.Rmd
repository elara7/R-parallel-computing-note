---
title: "R-parallel-computing-note"
author: "Zexian Wang"
date: "2017-5-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Motivation

- R core is a single-threaded program.

- Some times our tasks can be done at the same time using different cores/threads of cpus to speed up the codes.

# 2. How

There are two types of parallel computing.

## 2.1. Explicit parallelism

- `parallel` for "lapply"

- `foreach` for "for" 

- `SupR`

- `gpuR`

We need to modify/customize our codes in this case.

It is more flexible.

## 2.2. Implicit parallelism

- `OpenBLAS`/`intel MKL`/`NVIDIA cuBLAS`/`H2O`

We can install [Microsoft R Open](https://mran.microsoft.com/open/) to simplily enable intel MKL without any special operation.

We don't need to modify/customize our codes in this case. All the computation will be automatically accelerated. However, only some kinds of computation can be speed up.

# 3. Testing data and function

## 3.1. Data

```{r, include=FALSE}
source("case.R")
```

## 3.2. Function

```{r}
GetEstAUC <- function(data, method, t) {
  # Method: "Cox"
  auc <- risksetROC(Stime=data$T.20,
                    status=data$status.20, marker=data$M, method=method, 
                    predict.time = t, 
                    plot = F)
  auc$AUC
}

GetEstAUC.span <- function(data, method, t, n) {
  # Method: LocalCox", "Schoenfeld"
  auc <- risksetROC(Stime=data$T.20,
                    status=data$status.20, marker=data$M, method=method, 
                    predict.time = t, span = n^(-0.2),
                    plot = F)
  auc$AUC
}
```

## 3.3. Origin result

```{r}
cind.cox <- numeric(100)
est.diftime.cox <- matrix(NA, nrow = 100, ncol = 9)
for(i in 1:100) {
  auc <- risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)
  auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])
  est.diftime.cox[i, ] <- auc.est
  cind.cox[i] <- auc$Cindex
}
mean(cind.cox)
sd(cind.cox)
colMeans(est.diftime.cox)
apply(est.diftime.cox, 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

## 3.4. Origin speed

```{r}
microbenchmark::microbenchmark({
cind.cox <- numeric(100)
est.diftime.cox <- matrix(NA, nrow = 100, ncol = 9)
for(i in 1:100) {
  auc <- risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)
  auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])
  est.diftime.cox[i, ] <- auc.est
  cind.cox[i] <- auc$Cindex
}
mean(cind.cox)
sd(cind.cox)
colMeans(est.diftime.cox)
apply(est.diftime.cox, 2, sd)
},
times = 10)

# Unit: seconds
#      min       lq     mean   median       uq     max neval
# 3.315928 3.328301 3.36472 3.332089 3.429453 3.476224    10
```

# 4. Packages(Explicit parallelism)

## 4.1. Modify the funciton

Input index

```{r}
singlecox <- function(i){
  
  tryCatch({
    auc <- risksetROC::risksetAUC(Stime=SIM[[i]]$T.20,
       status=SIM[[i]]$status.20, marker=SIM[[i]]$M, method="Cox", 
       tmax=max(SIM[[i]]$T.20), plot = F)},
    warning = function(w){
      print(paste("warning auc",paste(i,auc$Cindex)))
      auc$Cindex <- NA
    },
    error = function(e){
      print(paste("error auc",paste(i,auc$Cindex)))
      auc$Cindex <- NA
    })
  
  tryCatch({
    auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = SIM[[i]])},
    warning = function(w){
      print(paste("warning auc.est",paste(i,auc.est)))
      auc.est <- rep(NA,9)
    },
    error = function(e){
      print(paste("error auc.est",paste(i,auc.est)))
      auc.est <- rep(NA,9)
    })
  
  return(c(auc.est,auc$Cindex))
}
```

Input data

```{r}
singlecoxdata <- function(data){
  
  tryCatch({
    auc <- risksetROC::risksetAUC(Stime=data$T.20,
       status=data$status.20, marker=data$M, method="Cox", 
       tmax=max(data$T.20), plot = F)},
    warning = function(w){
      print(paste("warning auc",paste(i,auc$Cindex)))
      auc$Cindex <- NA
    },
    error = function(e){
      print(paste("error auc",paste(i,auc$Cindex)))
      auc$Cindex <- NA
    })
  
  tryCatch({
    auc.est <- sapply(seq.time, GetEstAUC, method = 'Cox', data = data)},
    warning = function(w){
      print(paste("warning auc.est",paste(i,auc.est)))
      auc.est <- rep(NA,9)
    },
    error = function(e){
      print(paste("error auc.est",paste(i,auc.est)))
      auc.est <- rep(NA,9)
    })
  
  return(c(auc.est,auc$Cindex))
}
```


## 4.2. Parallel

### 4.2.1. Load package

```{r}
library(parallel)
```

### 4.2.2. Initial settings

```{r}
# Detect the numbers of cores of the cpu 
no_cores <- detectCores() 
# Initial the environment. In Linux, we can add type="FORK" to improve the performance of memory
# cl <- makeCluster(no_cores,type = "FORK") 
# cl <- makeCluster(no_cores) 
# Tell the machine that: these objects need to be used
#clusterEvalQ(cl,"risksetROC") # for packages
clusterExport(cl,c("risksetROC","risksetAUC","SIM","seq.ltime","seq.time","GetEstAUC","GetEstAUC.span")) # for functions and objects
```

### 4.2.3. Do the parallel compution using clusterApply/parLapply

```{r}
# Do the parallel compution
result <- clusterApply(cl,1:100,singlecox)
# Collect the result
result <- do.call(rbind,result)
# Get the result
mean(result[,10])
sd(result[,10])
colMeans(result[,1:9])
apply(result[,1:9], 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

```{r}
result <- parLapply(cl,1:100,singlecox)
# Collect the result
result <- do.call(rbind,result)
# Get the result
mean(result[,10])
sd(result[,10])
colMeans(result[,1:9])
apply(result[,1:9], 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

```{r}
# Do the parallel compution
result <- parLapply(cl,X=SIM,singlecoxdata)
# Collect the result
result <- do.call(rbind,result)
# Get the result
mean(result[,10])
sd(result[,10])
colMeans(result[,1:9])
apply(result[,1:9], 2, sd)

#[1] 0.7284767
#[1] 0.0196378
#[1] 0.7519363 0.7438530 0.7340835 0.7245257 0.7157358 0.7071073 0.6934697 0.6466489 0.5268098
#[1] 0.02758391 0.02583397 0.02342740 0.02103350 0.02001142 0.02225373 0.03329600 0.06151888 0.05608091
```

### 4.2.4. Speed Up!

```{r}
microbenchmark::microbenchmark({
result <- clusterApply(cl,1:100,singlecox)
result <- do.call(rbind,result)
mean(result[,10])
sd(result[,10])
colMeans(result[,1:9])
apply(result[,1:9], 2, sd)
},
times = 10)

# Unit: milliseconds
#      min       lq    mean  median       uq      max neval
# 942.2181 985.326 995.2975 996.673 1001.611 1041.534    10
```

```{r}
microbenchmark::microbenchmark({
result <- parLapply(cl,1:100,singlecox)
result <- do.call(rbind,result)
mean(result[,10])
sd(result[,10])
colMeans(result[,1:9])
apply(result[,1:9], 2, sd)
},
times = 10)

# Unit: milliseconds
                                                                                                                                                      
#      min       lq     mean   median       uq      max neval
# 869.4278 928.5966 964.0607 959.6331 1026.008 1039.143    10
```

```{r}
microbenchmark::microbenchmark(
  {
    # Do the parallel compution
result <- parLapply(cl,X=SIM,singlecoxdata)
# Collect the result
result <- do.call(rbind,result)
# Get the result
mean(result[,10])
sd(result[,10])
colMeans(result[,1:9])
apply(result[,1:9], 2, sd)
  },times = 10
)

#Unit: seconds
                                                                                                                                                                            
#      min       lq     mean   median       uq      max neval
# 9.121996 9.302989 9.430267 9.411168 9.579852 9.776635    10
```


### 4.2.5. Stop the parallel environment

```{r}
stopCluster(cl)
```

When you finish your parallel tasks, stop the parallel environment may avoid some unexpected problems.

## 4.3. Foreach

### 4.3.1. Load packages

```{r, include=FALSE}
library(foreach)
library(doParallel)
```

### 4.3.2. Initial settings 

```{r}
cl <- makeCluster(no_cores)
# we need register clusters
registerDoParallel(cl)
```

### 4.3.3. Do the parallel compution using foreach and %dopar%

```{r}
resultfor <- foreach(i = 1:100, 
                     .combine = rbind, # function that is used to process the tasks results as they generated
                #    .export = "xxx" # using this parameter to export functions or objects in parent's environments(generally no need)
                     .packages = "risksetROC" # using this parameter to tell machine what packages needed to be loaded
                ) %dopar% singlecox(i)
mean(resultfor[,10])
sd(resultfor[,10])
colMeans(resultfor[,1:9])
apply(resultfor[,1:9], 2, sd)

#[1] 0.7292839
#[1] 0.01758159
#[1] 0.7558782 0.7469039 0.7346733 0.7247788 0.7149696 0.7100356 0.6892987 0.6434846 0.5350352
#[1] 0.02683489 0.02480994 0.02144609 0.01948941 0.01823698 0.02104821 0.03134414 0.05997275 0.06606337
```

### 4.3.4. Speed Up!

```{r}
microbenchmark::microbenchmark({
resultfor <- foreach(i = 1:100, 
                     .combine = rbind,
                #    .export = "xxx" # using this parameter to export functions or objects in parent's environments(generally no need)
                     .packages = "risksetROC" # using this parameter to export packages
                ) %dopar% singlecox(i)
mean(resultfor[,10])
sd(resultfor[,10])
colMeans(resultfor[,1:9])
apply(resultfor[,1:9], 2, sd)
},
times =10)

#Unit: seconds
                                                                                                                                                      
#      min       lq     mean   median       uq      max neval
# 1.176546 1.245836 1.295963 1.314771 1.346413 1.39304    10
```

### 4.3.5. Stop the parallel environment

```{r}
stopImplicitCluster()
```

# 5. Recomdation

Using parLapply function with x = 1:100